import { CollapseCode } from "../../components/CollapseCode";

# Onchain Indices

This guide walks through how you can create onchain indices.

## What are indices?

In MUD, we can answer simple queries on-chain like _“what is Alice’s position?”_ with `Position.get(alice)`.

However, more complex applications require transformations of on-chain data that would be infeasible to compute on-chain. For example, _“which players are at this position?”_, or _“how many gold mines does Bob own?_.

For this reason, we create on-chain “indices” that maintain the result of these transformations.

## Indices in MUD - an example

Take this simple game where each account has an (x, y) position.

```ts filename="mud.config.ts" copy showLineNumbers
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
  tables: {
    Position: {
      keySchema: {
        player: "address",
      },
      valueSchema: {
        x: "int32",
        y: "int32",
      },
    },
  },
});
```

Players update their position by calling `MoveSystem.move` with their desired coordinates.

```solidity filename="MoveSystem.sol" copy showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { Position } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    Position.set(player, x, y);
  }
}
```

Now, we would like to prevent players from moving to positions that are already occupied:

   <CollapseCode>

```solidity filename="MoveSystem.sol" copy showLineNumbers {9-14}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { Position } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    bool positionIsEmpty = ?
    require(positionIsEmpty, "another player is at this position");

    Position.set(player, x, y);
  }
}
```

   </CollapseCode>

However, we only know on-chain the position of a given player, not which players are at each position; there is no reverse mapping. It’s time to add an index!

There are two main ways to implement this - **maintaining your own indices**, or **using a module**.

### Maintaining your own index

We can implement this by maintaining an index of which players are at a given position. Then, we know the position is empty if the list is empty.

First, we declare this `PlayersAtPostion` index in our MUD config. Note the schema is essentially the reverse of `Position`; the key is an (x, y) coordinate and the value is an array of addresses currently at that position:

   <CollapseCode>
```ts filename="mud.config.ts" copy showLineNumbers {14-17}
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
  tables: {
    Position: {
      keySchema: {
        player: "address",
      },
      valueSchema: {
        x: "int32",
        y: "int32",
      },
    },
    PlayersAtPosition: {
      keySchema: { x: "int32", y: "int32" },
      valueSchema: { players: "address[]" },
    },
  },
});
```

  </CollapseCode>

With our own indices, we need to be careful that they are maintained whenever the relevant tables are updated. If they are not kept up to date, they will not reflect current store data.

In this case, we need to add or remove addresses from `PlayersAtPosition` whenever a position changes. Let's add a `setPosition` helper function that sets both `Position` and the index:

```solidity filename="setPosition.sol" copy showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { Position, PositionData, PlayersAtPosition } from "../codegen/index.sol";

function filter(address[] memory arr, address element) pure returns (address[] memory) {
  address[] memory filtered = new address[](arr.length);
  uint256 filteredIndex;
  for (uint256 i; i < arr.length; i++) {
    if (arr[i] != element) {
      filtered[filteredIndex] = arr[i];
      filteredIndex++;
    }
  }

  // In-place update the length of the array
  // (Note: this does not update the free memory pointer)
  assembly {
    mstore(filtered, filteredIndex)
  }

  return filtered;
}

function setPosition(address player, int32 x, int32 y) {
	// Get the player's previous position
  PositionData memory previousPosition = Position.get(player);

 	// Remove the player from the index for the previous position
  PlayersAtPosition.set(
		previousPosition.x,
		previousPosition.y,
		filter(
	    PlayersAtPosition.get(previousPosition.x, previousPosition.y),
	    player
	  );
	);

	// Push the player to the index for the new position
  PlayersAtPosition.push(position.x, position.y, player);

	// Set the players position
  Position.set(player, position);
}
```

Then, whenever we set a position, we use `setPosition` instead of `Position.set`:

   <CollapseCode>

```solidity filename="MoveSystem.sol" copy showLineNumbers {5,11}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { setPosition } from "./setPosition.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    setPosition(player, x, y);
  }
}
```

   </CollapseCode>

Finally, we can check whether `PlayersAtPosition` is empty for a given position, meaning there are no players there:

   <CollapseCode>

```solidity filename="MoveSystem.sol" copy showLineNumbers {6,12-13}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { setPosition } from "./setPosition.sol";
import { PlayersAtPosition } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    bool positionIsEmpty = PlayersAtPosition.length(x, y) == 0;
    require(positionIsEmpty, "another player is at this position");

    setPosition(player, x, y);
  }
}
```

   </CollapseCode>

### Using modules - `KeysWithValue`

We can also use a MUD [Module](https://mud.dev/world/modules) to encapsulate the complexity of an index. The `KeysWithValue` module can be installed on tables, and maintains an array of keys with each value.

In our case, we install it for the `Position` table, in the `modules` property of our MUD config:

   <CollapseCode>
```ts filename="mud.config.ts" copy showLineNumbers {12-18}
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
	tables: {
		Position: {
		  keySchema: {
		    player: "address",
		  },
		  valueSchema: { x: "int32", y: "int32" },
		}
	},
  modules: [
    {
      name: "KeysWithValueModule",
      root: true,
      args: [resolveTableId("Position")],
    },
  ],
}
```

  </CollapseCode>

With this module, the index is automatically maintained when a position is set. Under the hood, this uses [Store Hooks](https://mud.dev/store/store-hooks).

Finally, we can get all keys with a given `Position` value:

```solidity filename="MoveSystem.sol" copy showLineNumbers {4,7,15-16}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { getKeysWithValue } from "@latticexyz/world-modules/src/modules/keyswithvalue/getKeysWithValue.sol";

import { System } from "@latticexyz/world/src/System.sol";
import { Position, PositionTableId } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    (bytes memory staticData, PackedCounter encodedLengths, bytes memory dynamicData) = Position.encode(x, y);

    bool positionIsEmpty = getKeysWithValue(PositionTableId, Position.encodeStatic(x, y), "", "").length == 0;
    require(positionIsEmpty, "another player is at this position");

    Position.set(player, x, y);
  }
}
```
